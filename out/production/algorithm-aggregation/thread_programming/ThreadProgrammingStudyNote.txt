多线程学习笔记

1、isAlive() ：判断当前线程是否存活
2、getId() : 获取线程唯一标识
3、在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，使之变成false
4、stop() ：暴力停止线程，已弃用
5、suspend() ：暂停线程
      resume() ：恢复线程
6、yield() : 放弃当前cpu资源，让其他任务去占用cpu执行时间。

线程是有优先级的（1~10），cpu会优先执行优先级较高的线程对象中的任务。
线程的优先级具有继承性，如果A线程启动B线程，则B线程的优先级与A一样的
优先级具有规则性：线程的优先级与代码执行顺序无关，cpu尽量将执行资源让给优先级比较高的线程
优先级具有随机性：一定优先级高的线程每次都先执行完，线程优先级具有随机性
优先级高的线程运行的快

在java线程中有两种线程，一种是用户线程，另一种是守护线程。
典型的守护线程就是垃圾回收线程

对象及变量的并发访问
* synchronize同步方法
1. 局部变量线程安全
   方法中的变量不存在非线程安全问题，永远是线程安全的。这是方法内部的变量是私有的特性造成的。
   方法中的私有变量不会先开辟出内存空间，而是等调用时在对应的调用线程中为方法中的变量申请空间，所以有几个线程调用则每个线程就会在自己的线程空间的栈为局部变量申请几个引用，同时，在堆中申请几个空间，所以多线程在调用时会处理自己线程内的方法的私有变量，因此，方法内的私有变量是线程安全的。

    2. 实例变量非线程安全
    在类的声明中，属性是用变量来表示的，这种变量就称为实例变量。
    多线程访问同一个对象中的同步方法时一定是线程安全的。

    3. 多个对象多个锁
    如果多个线程访问多个对象，则JVM会创建多个锁。

* synchronized方法与锁对象
* synchronized锁重入
   ”可重入锁“的概念是：自己可以再次获取自己的内部锁。
   synchronized拥有锁重入的功能，也就是说使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。
   可重入锁也支持在父子类继承的环境中。
* 出现异常，锁自动释放
   同步不可以继承，所以要在子类方法上加上synchronized关键字

* synchronized同步语句块
* 不在synchronized块中就是异步执行，在synchronized块中就是同步执行。
   synchronized代码块间的同步性